## 思路与想法
### 方法一：递归
**思路**：  
仔细观察可以发现，反转之后的二叉树相较于原来的二叉树只是左右孩子的位置换了一下，所以只要交换一个结点的左右孩子的值，然后递归地处理每一个结点即可。 

**算法**：
先定义一个头结点 `dummy`，然后写一个递归函数 `recur(p:TreeNode, q:TreeNode)` 用于将 `p` 结点的左右孩子的值(如果结点非空)分别赋给 `q` 结点的右左孩子.
然后执行递归函数，返回头结点 `dummy` 即可。  

**时间复杂度**：*O*(*N*)，其中*N*为二叉树的结点数。  
**空间复杂度**：*O*(*N*)。
