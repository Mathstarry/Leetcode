## 思路与想法
### 方法一：匈牙利算法
**思路**：  
题目要求一块骨牌可以覆盖2个格子，并且必须在同行或同列，那么可以分析出，每一个格子只能与其上下左右相邻的格子相连。注意到对于每一个格子，其行号与列号之和 `(i+j)` 的奇偶性与其相邻格子的奇偶性必定相反，
那么这就可以看成一个二分图，将格子分成三类，行列序号和为奇数一类，行列序号和为偶数一类，被破坏的格子一类。由于被破坏的格子不能被覆盖，所以在匹配时可以排除这一类，那么就只剩下两类了。
对于每一类中的格子，其只能与其相邻的格子相连，这等价于每一类中的点，只能与另一类中的不超过4个点匹配，且无法与同一类中的点匹配（因为相邻格子奇偶异性）。
问题所求为能覆盖的最大骨牌数，相当于求最大匹配的边数，因此可以使用匈牙利算法。

具体过程如下：  
1. 在外循环中，遍历所有行列序号和为奇数，且尚未被覆盖或者破坏的格子，对于每个符合条件的格子，进入内循环函数。
2. 在内循环中，对于该格子，去递归地寻找一条增广路径，若能找到，则使用该路径的匹配，否则，将该格子留空。在寻找增广路径时，要用一个集合存储已访问过的格子，防止成环超时。



**时间复杂度**：*O*(*N*<sup>4</sup>)，外循环遍历所有奇数点时间复杂度为 *O*(*N*<sup>2</sup>)，内循环中寻找增广路径最差时间复杂度为 *O*(*N*<sup>2</sup>)。  
**空间复杂度**：*O*(*N*<sup>2</sup>)，全部在原数组中修改，所以空间复杂度是 *O*(*N*<sup>2</sup>)。
