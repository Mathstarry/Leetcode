## 思路与想法
### 方法一：动态规划
**思路**：  
用 `dp[i]` 表示以数字 `nums[i]` 结尾的最长上升子序列的长度。所以对于每一个 `nums[i]`，我们都要比较之前的每一个 `dp[j]`，`dp[i] = max(dp[j]) + 1`，其中 `j` 满足 `nums[j] < nums[i]`。
用这个方法可以得到整个数组的最长上升子序列，最后只要返回 dp 数组的最大值即可，时间复杂度为*O*(*N*<sup>2</sup>)。

**时间复杂度**：*O*(*N*<sup>2</sup>)  
**空间复杂度**：*O*(*N*)
