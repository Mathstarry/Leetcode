## 思路与想法
### 关键词：`COUNT`, `rank()`, `dense_rank()`, `row_number()`
**思路一**：  
根据分数从高到低进行排名，且排名连续无断。考虑使用两张记有分数的表格，对于左边表格中的每一个分数，统计右侧表格中分数不小于它(且去重之后)的数量来作为左边分数的名次。例如：对于左边表格中最高的分数，
右边表格中不低于它且去重后的分数只有一个，所以左边表格中最高的分数的排名为 1。具体实现见方法一。


**思路二**：  
利用 SQL 的内置函数。对数据进行排名的函数有三种：  
1. `rank()`: 使用 `rank()` 进行排名时，相同的分数会得到相同的排名，并且每个分数的排名 = 分数比他严格要高的人数 + 1，也即排名不是连续的，是会出现空缺的；
2. `dense_rank()`: 使用 `dense_rank()` 进行排名时，相同分数会得到相同的排名，并且排名是连续的，例如即便有 3 个分数相同的人获得了第一名，但下一个最高的分数获得者仍然是第二名；
3. `row_number()`: 使用  `row_number()` 进行排名时，相同的分数会得到不同的排名，即保证名次是连续且唯一的。

在本题中使用 `dense_rank()` 进行排名是满足要求的。
