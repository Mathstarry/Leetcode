## 思路与想法
### 方法一：非递归方法
**思路**：  
先定义一个空集为解集，对于数组 `nums` 中的第一个元素，我们把它加入空集中并添加到解集后，那么解集变成了 `[ [], [nums[0]] ]`。对于数组中的第二个元素，我们依次添加到解集的元素中，
并把得到的新数组添加到解集后，可以得到 `[ [], [nums[0]], [nums[1]], [nums[0], nums[1]] ]`。类似地，对于数组中的第 `k` 个元素 `nums[k-1]`，我们把它依次添加到解集的各个数组中，
并把得到的新数组添加到解集后，这样每次解集的长度都是乘以2，添加 *N* 个元素，解集的长度就由 1 变成了 2<sup>*N*</sup>。

### 方法二：位运算法
**思路**：  
建立一个大小为 2<sup>*N*</sup> x *N* 的数组，接下来两层循环，外循环用 `i` 遍历 0 ～ 2<sup>*N*</sup> - 1，内循环用 `j` 遍历 0 ~ N - 1，考虑 `i` 的二进制形式，是一个长度为 *N* 的
数组，每次执行判断` (i >> j) & 1`，判断 `i` 的从右往左第 `j` 位是否为 `1`。若为真，则选中数组 `nums` 中从右往左第 `j` 位的数字，等内循环结束，则选出了在 `i` 下数组 `nums` 中被选中的数字，将这些数字组成的数字添加到解集中即可。事实上解集就是数组 `nums` 中每一个数字被选中或未被选中组成的集合，这也是位运算想法的来源。

**时间复杂度**：*O*(*N* * 2<sup>*N*</sup>)  
**空间复杂度**：*O*(*N*)
