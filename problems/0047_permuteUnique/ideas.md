## 思路与想法
### 方法一：排列组合
**思路**：  
排列组合问题重点是两个，一个是查全，把所有状态查出来，第二个是去重，把重复的状态去掉。  
对于去重，一个很重要的预处理就是排序。对于无重复数字的序列(可不排序)，可以建立一个数组用来记录对应索引的数字是否已被选取，然后把已选取数字组成的数组和索引数组传入递归函数，递归地求出所有排列即可。

由于本题中存在重复的数字，所以需要做第二个去重处理。如下图所示：  
![](https://github.com/Mathstarry/Leetcode/blob/master/problems/0047_permuteUnique/img/47_pic1.png)

对于输入 `[1, 1, 2]`，当我们考虑数组第一层放置的数字时，若某一数字没有被放入过这一层，则放入，并继续递归，若之前已有相同数字被放入过这一层，则剪枝，这就是“同层之间相同数字只保留最先出现的分支”。由于我们已经对数组进行了排序，所以相同数字必定相邻，在程序中判定时的核心代码语句是；  
```
if i > 0 and nums[i] == nums[i-1] and rest[i-1] == 1:
	continue
```
对于第一个数字，不可能之前有与之相同的数字被放入过这一层；对于之后的数字，若某一数字与其前一位的数字相同，并且他前一位的数字仍处于未被选取状态，表明该数字之前已有相同数字在这一层展开递归，所以我们把它剪枝掉。如果某一数字出现了若干次，该规则仍然适用，可以把第二次及之后出现的相同数字全剪枝掉。  
如果当某一数字与其前一位数字相同时，其前一位数字已经被选取，表明这两个数字是处于不同层的，所以可以继续展开。


**时间复杂度**：*O*(*N* * *N* *!*)  
**空间复杂度**：*O*(*N*)
