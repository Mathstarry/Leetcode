## 思路与想法
### 方法一：动态规划
**思路**：  
使用动态规划解决问题，要首先明确两点：  
1. 状态：定义 `dp[i][j]` 表示前 `i` 个数字以 `j+1` 结尾的种类数；
2. 转移：前 `i` 个数字中，以数字 `j+1` 结尾的种类数 **等于** 前 `i-1` 个数字中，以六种数字结尾的种数之和，再 **减去** 前 `i-1` 个数字中，以连续 `rollMax[j]` 个数字 `j+1` 结尾的种类数。
   表达成程序语句就是 `dp[i][j] = sum(dp[i-1]) - sum(dp[i-rollMax[j]-1]) + dp[i-rollMax[j]-1][j]`。  
如果当前数组的长度 `i` 小于 `rollMax[j]`，则不需要减去这一部分；如果减去这一部分后，数组长度为 0，则只需减去 1 即可。


**时间复杂度**：*O*(*N*)  
**空间复杂度**：*O*(*N*)
