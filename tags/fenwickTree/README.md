# 树状数组
在树状数组中，数组是名词，树是定语，所以本质上还是一个数组，但是我们把数组排列成了树形结构。  
不妨考虑一个长度为 `n` 的数组，数组的特性是可以通过索引 O(1) 地访问每一个元素的值，但是如果想要求前 `i` 项和，就需要 O(*N*) 的时间，为了更快地得到前 `i` 项和，考虑另外用一个长度为 `n` 的数组
记录原数组的前 `i` 项和，称之为前缀和数组，这样就可以 O(*1*) 地得到原数组的前 `i` 项和，但是每当原数组中的某一个值改变时，我们就需要 O(*N*) 地去改变前缀和数组的前 `i` 项的值。

为了更快地访问和更新原数组的前 `i` 项和信息，提出了树状数组的概念，如下图所示：


<img src="https://github.com/Mathstarry/Leetcode/blob/master/tags/fenwickTree/img/pic.png" width = "900" height = "500" alt="" align=center />

需要注意的是，树状数组的索引所从 1 开始的，原因在后面解释，所以可以考虑使用字典结构来存储树状数组的键值对，键为 1~n。如图所示，索引为奇数(从 1 开始索引)的元素值为原数组中的值，索引为偶数的元素
值可能为该索引往前 2 项、4 项、8 项之和等。  
树状数组有两个方法:  
1. 更新: 更新索引 `i` 指向的元素的值，以及其“父结点”的索引值；
2. 返回前缀和: 返回原数组前 `i` 项的和。

不妨考虑一个长度为 8 的数组，索引为 1~8，假设我们要更新索引 3 指向的元素的值，改变量为 `v`，那么该元素执行 `+v` 的操作，然后，依次对该元素的所有父节点执行 `+v` 操作。因为在树状数组中，每一个节点的值为其本身和其所有子节点所对应的原数组中的值之和，比如 `C[5] = A[5], C[6] = C[5] + A[6] = A[5] + A[6]`。

继续考虑图中的的树状数组，现在要要返回原数组的前 6 项和，那么需要返回的值为 `C[6] + C[4]`。




## 树状数组题目

### 简单


---
### 中等


---
### 困难
[offer51. 数组中的逆序对](https://github.com/Mathstarry/Leetcode/tree/master/getOffer/offer51_reversePairs)
