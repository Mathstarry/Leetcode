# 树状数组
在树状数组中，数组是名词，树是定语，所以本质上还是一个数组，但是我们把数组排列成了树形结构。  
不妨考虑一个长度为 `n` 的数组，数组的特性是可以通过索引 O(1) 地访问每一个元素的值，但是如果想要求前 `i` 项和，就需要 O(*N*) 的时间，为了更快地得到前 `i` 项和，考虑另外用一个长度为 `n` 的数组
记录原数组的前 `i` 项和，称之为前缀和数组，这样就可以 O(*1*) 地得到原数组的前 `i` 项和，但是每当原数组中的某一个值改变时，我们就需要 O(*N*) 地去改变前缀和数组的前 `i` 项的值。

为了更快地访问和更新原数组的前 `i` 项和信息，提出了树状数组的概念，如下图所示：


<img src="https://github.com/Mathstarry/Leetcode/blob/master/tags/fenwickTree/img/pic.png" width = "900" height = "500" alt="" align=center />

需要注意的是，树状数组的索引所从 1 开始的，原因在后面解释，所以可以考虑使用字典结构来存储树状数组的键值对，键为 1~n。如图所示，索引为奇数(从 1 开始索引)的元素值为原数组中的值，索引为偶数的元素
值可能为该索引往前 2 项、4 项、8 项之和等。  
树状数组有两个方法:  
1. 更新: 更新索引 `i` 指向的元素的值，以及其“父结点”的索引值；
2. 返回前缀和: 返回原数组前 `i` 项的和。

不妨考虑一个长度为 8 的数组，索引为 1~8，假设我们要更新索引 3 指向的元素的值，改变量为 `v`，那么该元素执行 `+v` 的操作，然后，依次对该元素的所有父节点执行 `+v` 操作。因为在树状数组中，每一个节点的值为其本身和其所有子节点所对应的原数组中的值之和，比如 `C[5] = A[5], C[6] = C[5] + A[6] = A[5] + A[6]`。

继续考虑图中的的树状数组，现在要要返回原数组的前 6 项和，那么需要返回的值为 `C[6] + C[4]`。

树状数组使用的要求是索引从 1～n，在实际使用中，会碰到 `n` 非常大，但是数组元素非常稀疏（即很多值为 0）的情形，如果这时候对整个数组构建树状数组将会浪费很大的空间和时间。为了解决上述问题，引入了
离散化对操作，即只对非零元素构建树状数组，从而可以大大减小树状数组的大小。

## 算法
在实现树状数组的时候要解决两个问题，一是更新节点时，如何找到目标节点的所有父节点；另一个是计算前缀和时，如何找到所有需要节点，并计算和。

1. 更新: 节点的索引是从 1 开始且连续的，我们使用二进制来表示节点的索引。不难发现在 1～8 中，节点 1 的父节点依次为 1-2-4-8，他们的二进制表示(仅显示最低四位)为 0001-0010-0100-1000。
   这里引入"最低位 1(lowbit)" 的概念，表示的是某个数二进制表示中最低位的 1 及其后面的 0 所组成的数字，例如 6(0110) 的最低位 1 是 2(0010)。那么，每个节点的父节点的索引实际上就是该节点
   的索引和它最低位 1 和，即 `fa(x) = x & lowbit(x)`。最低位 1 的计算公式为 `lowbit(x) = x & (-x)`, where `-x = ~x + 1`。
2. 返回前缀和: 比如说我们要返回索引 7(0111) 的前缀和，事实上就是要返回 `C[7] + C[6] + C[4]`，只要我们能够通过索引 7 快速得到 6 和 4 的索引，就可以计算出前缀和。事实上对每个节点，他的索引
   的二进制表示减去其最低位 1 就可以得到下一位需要的索引的二进制，例如 `7(0111) - lowbit(7) = 0111 - 0001 = 0110 = 6`, `6(0110) - lowbit(6) = 0110 - 0010 = 0100 = 4`, 
   ` 4(0100) - lowbit(4) = 0100 - 0100 = 0`，直到索引为 0 为止，把之前计算出的每个索引对应的值相加，就可以得到前缀和。




## 树状数组题目

### 简单


---
### 中等


---
### 困难
[offer51. 数组中的逆序对](https://github.com/Mathstarry/Leetcode/tree/master/getOffer/offer51_reversePairs)
