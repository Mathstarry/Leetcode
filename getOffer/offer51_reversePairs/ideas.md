## 思路与想法
### 方法一：归并排序
**思路**：  
对于每一个数 k, k 的逆序数等于其后面比它小的数字的数量，相当于把比 k 小的数字都移到 k 的前面需要移的数量。所以任意的排序算法理论上都是可以的，只要计算大的数字被其小的数字往前移的次数即可。
这里使用归并排序进行计数，归并排序的模板见**排序(暂未更新)**。

### 方法二：树状数组
**思路**：  
关于树状数组的详细内容见**树状数组(暂未更新)**，这里主要利用了树状数组花 *O*(*log*(*N*)) 的时间可以计算前缀和的特性。  
第一步：把数组离散化，把数组的值转换成相应的排名。  
第二步：从右往左遍历数组，每遇到一个数字，就把该数字更新到树状数组上，并计算前缀和(不包括其本身)作为该数字右侧比它小的数字的数量。这样就可以以总的 *O*(*N* * *log*(*N*)) 的时间代价完成任务。


**时间复杂度**：*O*(*N* * *log*(*N*))  
**空间复杂度**：*O*(*N*)
