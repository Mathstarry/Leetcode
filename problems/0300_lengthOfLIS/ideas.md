## 思路与想法
### 方法一：动态规划
**思路**：  
用 `dp[i]` 表示以数字 `nums[i]` 结尾的最长上升子序列的长度。所以对于每一个 `nums[i]`，我们都要比较之前的每一个 `dp[j]`，`dp[i] = max(dp[j]) + 1`，其中 `j` 满足 `nums[j] < nums[i]`。
用这个方法可以得到整个数组的最长上升子序列，最后只要返回 dp 数组的最大值即可，时间复杂度为*O*(*N*<sup>2</sup>)。

**时间复杂度**：*O*(*N*<sup>2</sup>)  
**空间复杂度**：*O*(*N*)


### 方法二：贪心+二分
**思路**：  
定义 `res[i]` 表示长度为 `i+1` 的上升子序列的值，因此整个 `res` 序列必定是单调递增的。  
我们的做法是，先定义一个长度为 1 的数组 `res`，其元素为 `nums[0]`。然后对于 `nums` 中的每一个元素：
1. 若 `nums[i] > res[-1]`, 则直接把该元素 `append` 到 `res` 末尾，因为他一定是比目前最长的上升子序列的最大值要大的。
2. 若 `nums[i] <= res[-1]`, 我们使用二分搜索寻找 `res` 中比 `nums[i]` 大的第一个元素，并将其置换为 `nums[i]`。这么做是因为，这么调换不影响目前维护的所有长度的上升子序列的长度，且可以将
其中的元素变得更小，那么之后我们就可以将尽可能多的元素替换进来，避免数组中出现最大值以致后面较大的数字添加不进来的问题。


**时间复杂度**：*O*(*N* *log*(*N*))  
**空间复杂度**：*O*(*N*)
