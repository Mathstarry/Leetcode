## 思路与想法
### 方法一：动态规划
**思路**：  
这题与力扣[221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)很像，不过这题只要求正方形的四边为 0 即可，不要求内部是否为 0。
想法是定义两个二维数组 `left`, `upon`，分别记录当前位置向左有多少个连续的 0 和当前位置向上有多少个连续的 0。这么定义的原因是，我们是从左上向右下遍历矩阵的，所以这么定义方便写状态转移方程。
不妨设遍历到位置 `(i, j)` 时，当前的最大方阵边长为 `ans`，那么我们先取出该点向左的连续 0 长度和向上的连续 0 长度的较小值 `v = min(left[i][j], upon[i][j]`，因为方阵的边长是有长和宽的
较小值决定的。接下来进入第二个循环，同时开始 `(i, j-v)` 向右遍历和 `(i-v, j)` 向下遍历，当同时满足 `(i, j-v)` 向上的连续 0 个数与 `(i-v, j)` 向左的连续 0 个数都不小于他们距离 `(i, j)` 
点的距离时，表明此时构成一个以 `(i, j)` 为右下角点的最大方阵，方阵的边长为移动点到 `(i, j)` 的距离。

**优化**：  
注意到二维数组 `upon` 在实际使用中，对于每一个位置 `(i, j)` ，我们只需要用到它左边不多于 `v` 个点的 `upon[i][j-k]` 的值，并且更新 `upon[i][j]` 的值只与 `upon[i-1][j]` 的值和
`matrix[i][j]` 的值有关，所以不难想到使用一个一维数组来储存 `upon` 即可。其中 `upon[j]` 表示某一行第 `j` 列的位置向上有多少个连续的 0 （包含该点本身）。 由于只使用一维数组来记录 `upon`，
所以在更新 `upon[j]` 的值时要注意，若 `matrix[i][j] == 1`，则需令  `upon[j] = 0`。 


**时间复杂度**：*O*(*N*<sup>2</sup>)  
**空间复杂度**：*O*(*N*<sup>2</sup>)
