## 思路与想法
### 方法一：动态规划
**思路**：  
建立一个大小为 `n*(6n)` 的数组，用以存储在有若干个骰子时，能够掷出每个数字的次数。因为 `k` 个骰子掷出的数必定在 k~6k 之间，所以循环时第二层循环可以写范围一点。  
* 状态: dp[i][j] 表示使用 `i+1` 颗骰子能够掷出数字 `j+1` 的次数。
* 转移: dp[i][j] = dp[i-1][j-6] + dp[i-1][j-5] + dp[i-1][j-4] + dp[i-1][j-3] + dp[i-1][j-2] + dp[i-1][j-1]
状态转移时，在 `i` 颗骰子掷出数字 `j` 的情况下， 如果第 `i+1` 颗骰子能够掷出 `1`，就能够得到 `j+1`，即 `dp[i][j] += dp[i-1][j-1]`，其余 5 个数字同理。
但这里需要注意下边界问题，一个是在投第一颗骰子时，不能使用状态转移方程，而是需要先预定义为 1；二是每个状态下，骰子掷出的数字和不能小于骰子的数量。所以需要对状态转移方程稍作修改。


**时间复杂度**：*O*(*N*<sup>2</sup>)  
**空间复杂度**：*O*(*N*<sup>2</sup>)
