## 思路与想法
### 方法一：位运算
**思路**：  
因为结果不会溢出 32 位整数，所以时间空间复杂度都是常数。  
不妨先考虑 a 和 b 都是正整数的情形，如果 `a & b == 0`，显然此时 `a ^ b` 就等于 `a + b`，但是如果 a 和 b 中存在某一些二进制位置同为 1，那么就会导致 `a ^ b` 的这几位变成 0。为了解决这个问题，
我们先令 `c = a & b`，记录下 a 和 b 中所有同为 1 的那几位，在 a 与 b 相加时，相同位为 1 的话，应该是进位的效果，所以再令 `c = c << 1` 之后加到 `a ^ b` 上即可。但有可能仍存在进位的情形，
所以我们要写一个循环，一直循环直到 `c = 0` 为止。

对于 a 和 b 存在负数的情形，也同样符合上述推理过程，所以可以使用同样的公示。但是由于python语言的特性，我们在对一个数字取反之后，它并不是只有32位内的左侧取 1，为了把 1 的数量限制在 32 位以内，
我们还要将每一个数字与 2**32 - 1 取与，也即 `oxffffffff`。


**时间复杂度**：*O*(*1*)  
**空间复杂度**：*O*(*1*)
