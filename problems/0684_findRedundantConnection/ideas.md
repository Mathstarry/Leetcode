## 思路与想法

### 方法一：并查集
**思路**：  
由于该图为无向图，我们的目标是检测出环的位置，并去掉环上最后被添加的一条边，很容易想到可以使用并查集。对于输入的每一对顶点，把他们依次添加到并查集中，当添加某一对顶点的时候，发现他们已经联通了，
那表示如果连上这一条边将导致成环，此时返回这对顶点即可。由于我们只关心两个点是否联通，并不关心顺序问题，所以可以使用路径压缩的并查集来加快 `find()` 的速度。

**时间复杂度**：遍历所有顶点对的复杂度是 *O*(*N*)，在寻找每对顶点的祖结点时，时间是小于 *O*(*N*) 的，所以总的时间复杂度要好与 *O*(*N*<sup>2</sup>)，略坏于 *O*(*N*)。  
**空间复杂度**：*O*(*N*)，这里需要用一个列表存储每个顶点的 `root`，若使用路径压缩，则还需要一个列表存储每个顶点的 `rank`。
