## 思路与想法
### 方法一：BFS
**思路**：  
单词接龙 II 需要解决两个问题：  
1. 如何快速找到每个单词可以转换的单词
2. 如何保存所有最短的路径

解决方案如下：  
1. 预处理单词列表，建立一个字典，字典的键为所有单词的蒙板(即遮盖掉单词中的某一个字母，一个单词最多可以产生 *C* 个蒙板，*C* 为单词的长度)，值为与该蒙版匹配的所有单词。
2. 从起点出发，用BFS进行遍历，遍历时，队列中的元素为起点之当前单词的路径。使用BFS第一次遇到结束单词的时间点必定是最短的路径，返回第一次遇到结束单词时，所以遇到结束单词的路径即可。

### 方法一：双向BFS
为了加快遍历的速度，使用双向BFS，即同时从起点和终点开始向中间进行BFS遍历，当第一次两边的遍历相遇时，就是最短路了。操作上稍微繁琐一些，但是可以节省时间。


**时间复杂度**：*O*(*N*<sup>2</sup> * *C*)  
**空间复杂度**：*O*(*N*<sup>2</sup> )
